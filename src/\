
#ifndef CACHE_H
#define CACHE_H

#include <assert.h>
#include "util.h"
#include "memory.h"
using namespace std;

struct CacheLine {
    u32 data_size = 0;
    u32 meta = 0;
        // this meta data contains meta data
        // [tag][age][dirty bit]
        // TO-DO implement proper masks and shifts
    char * data = nullptr;

    CacheLine() {}
    ~CacheLine() { if (data) delete[] data; }

    char& operator [](u32 index) {
        assert(index < data_size);
        return data[index];
    }
};

class Cache {
protected:
    u32 num_sets; // number of associative sets
    u32 n_way;      // number of lines per set
    CacheLine ** sets; // 2D array memory
    Memory * ram;

    // helper masks and shifts
    u32 byte_mask;  // for index of individual byte per cache line in set
    u32 assoc_mask; // for index of set in sets
    u32 tag_mask;   // for tag comparison
    u32 assoc_shift;

    bool write_back;

public:
    /**
     * Constructor
     *  @param cache_size   size in bytes of the cache
     *  @param line_size    size of each cache line: number of bytes per block
     *  @param n_way        set associativity: lines per set
     */
    explicit
    Cache(u32 cache_size, u32 line_size, u32 n_way, u32 ram_size) {
        if ( !util::is_pow2(cache_size)
             || !util::is_pow2(cache_size)
             || !util::is_pow2(n_way) ) {
            cerr << "ERROR! cache_size and line_size must be a power of 2!"
                 << endl;
            throw std::exception();
        }

        if (cache_size < (line_size * n_way)) {
            cerr << "Invalid ratio of parameters: "
                 << "cache_size : " << cache_size << endl
                 << "line_size  : " << line_size << endl
                 << "n_way      : " << n_way << endl;
            throw std::exception();
        }

        num_sets = cache_size / line_size / n_way;
        sets = new CacheLine*[num_sets];

        // initialize array
        for (u32 i = 0; i < num_sets; i++) {
            sets[i] = new CacheLine[n_way];
            for (u32 j = 0; j < n_way; j++) {
                sets[i][j].data_size = line_size;
                sets[i][j].data = new char[line_size];
            }
        }

        byte_mask   = line_size - 1;
        assoc_mask  = (num_sets - 1) << util::log2(line_size);
        assoc_shift = util::log2(line_size);
        tag_mask    = ~(byte_mask | assoc_mask);

        ram = new Memory(ram_size);
    }

    ~Cache() {
        if (sets) {
            for (; --num_sets >= 0; delete[] sets[num_sets]);
            delete[] sets;
        }
    }

    /** For LRU
     * ages every cacheline's age 
     */
    inline void age_set(CacheLine * set) {
        for (u32 i = 0; i < n_way; ++i) {
            set[i].meta++; // is wrong not correct
        }
    }

    /** find(@addr, @set, @index)
     *  returns: bool if addr is in this cache
     *
     *  behavior:
     *  if the @addr is contained in the cache, 
     *  this function sets @set to the set line
     *  and sets index to the index of the cache line
     *  in that set
     *
     *  if @addr is not in the cache, it sets index
     *  to the index of the cacheline which is oldest
     *  for LRU replacement
     *
     *  to access the cacheline -> set[index]
     */
    bool find_in_cache(u32 addr, Cache * &set, u32 &index) {
        set = sets[(addr & assoc_mask) >> assoc_shift];
        u32 oldest = 0;
        for (u32 p, p < n_way; p++) {
            if ( (addr & tag_mask) == (set[p].meta & tag_mask) ) {
                index = p;
                return true;
            }

            // simultaneously find oldest index for lru
            if ( ((set[p].meta & (~tag_mask)) >> 1) >
                 ((set[oldest].meta & (~tag_mask)) >> 1)) {
                oldest = p;
            }
        }
        // replace this block

        index = oldest;
        if (write_back && (set[oldest].meta & 1)) {
            // if using write back policy and this block is dirty
            write_block_to_memory(set, addr);
        }
        fetch_block_from_memory(set, addr);
        return false;
    }

    void store_byte(u32 addr, char value) {
        //TO-DO
        CacheLine * set;
        u32 index;

        find(addr, set, index);
        set[index][addr & byte_mask] = value;
        set[index].meta &= (tag_mask | 1); // set age = 0
    }

    void store_word(u32 addr, u32 word) {

    }

    void load_word(u32 &reg, u32 addr) {
        assert(!(addr & byte_mask)); // check if word aligned
        CacheLine * set;
        u32 index;
        find_in_cache(addr, set, index);
    }

protected:
    /**
     * copies a block of memory from ram into this cache line
     */
    void fetch_block_from_memory(CacheLine *line, u32 addr) {
        assert(line != nullptr);
        line->meta &= (~tag_mask);       // remove old tag
        line->meta |= (addr & tag_mask); // put new tag
        line->meta &= -2;                // set dirty bit to 0

        addr &= (~byte_mask);  // change addr to where the block starts

        for (u32 p = 0; p <= byte_mask; ++p) {
            (*line)[p] = ram[addr + p];  // copy values
        }
    }

    /**
     * copies a data in cache line into block of memory
     */
    void write_block_to_memory(CacheLine *line, u32 addr) {
        assert(line != nullptr);
        line->meta &= -2;      // set dirty bit to 0
        addr &= (~byte_mask);  // change addr to where the block starts

        for (u32 p = 0; p <= byte_mask; ++p ) {
            ram[addr+p] = (*line)[p];
        }
    }
};

#endif

